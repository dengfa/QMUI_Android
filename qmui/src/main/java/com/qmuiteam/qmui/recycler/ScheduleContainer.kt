package com.qmuiteam.qmui.recyclerimport android.content.Contextimport android.graphics.Canvasimport android.graphics.Colorimport android.graphics.Paintimport android.graphics.Rectimport android.util.AttributeSetimport android.util.Logimport android.view.ViewGroupimport android.widget.FrameLayoutimport android.widget.ListViewimport android.widget.TextViewimport androidx.recyclerview.widget.RecyclerViewimport com.qmuiteam.qmui.dpimport com.qmuiteam.qmui.dpF/** * Created by dengfa on 2022/1/27 * 1.滑动时每addView一个新的View都会触发onlayout */class ScheduleContainer @JvmOverloads constructor(context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : FrameLayout(context, attrs, defStyleAttr) {    private val DEFAULT_BLOCK_SIZE: Int = 85.dp    private val ROWS_CNT = 24    private var paint = Paint(Paint.ANTI_ALIAS_FLAG)    private var highlightPaint = Paint(Paint.ANTI_ALIAS_FLAG)    var columns = 7    var blockWidth = 85.dp    var blockHeight = 85.dp    var timeLineWidth = 58.dp    var timeLineTextSize = 10.dp    val tasks: ArrayList<Task> = arrayListOf()    var parentHeight = 0    var scrollerY = 0    val taskInScreen: HashMap<Task, TaskView> = HashMap()    val taskRecycler = TaskRecycler()    init {        highlightPaint.color = Color.parseColor("#FFF2CE")        highlightPaint.style = Paint.Style.FILL        setWillNotDraw(false)    }    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {        super.onSizeChanged(w, h, oldw, oldh)        blockWidth = (width - timeLineWidth) / columns        blockHeight = (height - timeLineTextSize) / ROWS_CNT        if (parent is ViewGroup) {            parentHeight = (parent as ViewGroup).height        }        Log.i("vincent", "ScheduleContainer onSizeChanged parentHeight $parentHeight")        removeAll()        refreshTasks(tasks)    }    private fun removeAll() {        removeAllViews()        //处理回收        taskRecycler.recycleAll(taskInScreen.values)        taskInScreen.clear()    }    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec)        Log.i("vincent", "ScheduleContainer onMeasure")        val widthSize = MeasureSpec.getSize(widthMeasureSpec)        val heightSize = MeasureSpec.getSize(heightMeasureSpec)        if (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT && layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) {            setMeasuredDimension(DEFAULT_BLOCK_SIZE * columns, DEFAULT_BLOCK_SIZE * ROWS_CNT + timeLineTextSize)        } else if (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT) {            setMeasuredDimension(DEFAULT_BLOCK_SIZE * columns, heightSize)        } else if (layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) {            setMeasuredDimension(widthSize, DEFAULT_BLOCK_SIZE * ROWS_CNT + timeLineTextSize)        }    }    private val textBoundsRect = Rect()    override fun onDraw(canvas: Canvas) {        super.onDraw(canvas)        for (i in 0 until ROWS_CNT + 1) {            val y = blockHeight * i.toFloat() + timeLineTextSize / 2            paint.strokeWidth = 1.dpF            paint.color = 0x1A000000            canvas.drawLine(timeLineWidth.toFloat(), y, width.toFloat(), y, paint)            paint.textSize = timeLineTextSize.toFloat()            paint.color = Color.parseColor("#2B2D33")            val timeStr = "${if (i < 10) "0" else ""}$i:00"            paint.getTextBounds(timeStr, 0, timeStr.length, textBoundsRect)            canvas.drawText(timeStr, (timeLineWidth - textBoundsRect.width()) / 2f, y + textBoundsRect.height() / 2, paint)        }    }    override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) {        super.onLayout(changed, left, top, right, bottom)        Log.i("vincent", "ScheduleContainer onLayout")    }    private fun getRect(start: Float, end: Float, index: Int): Rect {        val top = start * blockHeight + timeLineTextSize / 2        val bottom = end * blockHeight + timeLineTextSize / 2        val left = timeLineWidth + index * blockWidth        val right = timeLineWidth + (index + 1) * blockWidth        return Rect(left, top.toInt(), right, bottom.toInt())    }    fun onScroll(l: Int, t: Int, oldl: Int, oldt: Int) {        Log.i("vincent", "ScheduleContainer onScroll scrollY $t childCount ${childCount}")        scrollerY = t        refreshTasks(tasks)    }    fun setTask(tasks: List<Task>) {        this.tasks.apply {            clear()            addAll(tasks)        }        removeAll()        post {            refreshTasks(tasks)        }    }    private fun refreshTasks(tasks: List<Task>) {        tasks.forEach { task ->            val rect = getRect(task.start, task.end, task.index)            task.rect = rect            if (rect.top - scrollerY <= parentHeight && rect.bottom - scrollerY >= 0 && !taskInScreen.contains(task)) {                Log.i("vincent", "addView $this tasksAdded ${taskInScreen.size}")                val taskView = taskRecycler.obtain(context)                taskView.setText(task.taskName)                taskView.setBackgroundColor(Color.parseColor("#EFF6FF"))                //使用addViewInLayout，传preventRequestLayout未true，不会额外回调onlayout                //addViewInLayout(taskView, -1, LayoutParams(rect.right - rect.left, rect.bottom - rect.top), true)                taskView.x = rect.left.toFloat()                taskView.y = rect.top.toFloat()                addView(taskView, rect.right - rect.left, rect.bottom - rect.top)                //taskView.layout(rect.left, rect.top, rect.right, rect.bottom)                taskInScreen[task] = taskView            } else if ((rect.top - scrollerY > parentHeight || rect.bottom - scrollerY < 0) && taskInScreen.contains(task)) {                //不在屏幕内，且被添加到容器                taskInScreen[task]?.let {                    //removeViewInLayout(it)                    removeView(it)                    taskRecycler.recycle(it)                }                taskInScreen.remove(task)            }        }    }}data class Task(    var index: Int = 0,    var start: Float = 0f,    var end: Float = 0f,    var taskName: String = "",    var rect: Rect = Rect(),) {    override fun toString(): String {        return "index $index $start-$end"    }}